package org.fundamentals.fp.euler;

import io.reactivex.Observable;
import io.reactivex.Single;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import reactor.core.publisher.Mono;
import reactor.math.MathFlux;

/**
 * https://projecteuler.net/problem=2
 *
 * Original:
 *
 * Each new term in the Fibonacci sequence is generated by adding the previous two terms.
 * By starting with 1 and 2, the first 10 terms will be:
 *
 * 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
 *
 * By considering the terms in the Fibonacci sequence whose values
 * do not exceed four million, find the sum of the even-valued terms.
 *
 * Further information about a Fibonacci serie:
 * https://en.wikipedia.org/wiki/Fibonacci_number
 *
 * Scenario 100:
 *
 * Given a Fibonacci sequence:
 * 1, 2, 3, 5, 8, 13, 21, 34, 55, 89
 *
 * When execute sumEven method
 * Then find the sum of the even-valued terms
 *
 */
@Solved
public class EulerProblem02 implements IEulerType1 {

    @Override
    public long JavaSolution(long limit) {

        long sum = 0L;
        for (long number : Utils.Java.fibonacci(limit)) {

            if ((number % 2) == 0) {
                sum += number;
            }
        }

        return sum;
    }

    Predicate<Long> isEven = number -> (number % 2) == 0;

    @Override
    public long JavaStreamSolution(long limit) {

        return Utils.JavaStreams.fibonacci(limit)
                .filter(isEven)
                .collect(Collectors.summingLong(Long::longValue));
    }

    @Override
    public long VAVRSolution(long limit) {

        return Utils.VAVR.fibonacci(limit)
                .filter(isEven)
                .reduce(Long::sum);
    }

    @Override
    public Mono<Long> ReactorSolution(long limit) {

        return MathFlux.sumLong(Utils.Reactor.fibonacci(limit)
                .filter(isEven));
    }

    @Override
    public long KotlinSolution(long limit) {

        return EulerProblem02Kt.KotlinSolution02(limit);
    }

    io.reactivex.functions.Predicate<Long> RxIsEven = number -> (number % 2) == 0;

    @Override
    public Single<Long> RxJavaSolution(long limit) {

        return Observable.fromArray(0L)
                .repeat()
                .scan(new long[]{0, 1}, (a, b) -> new long[]{a[1], a[0] + a[1]})
                .map(a -> a[1])
                .takeWhile(x-> x <= limit)
                .filter(RxIsEven)
                .reduce(0L, (a, b) -> a + b);
    }
}
